import argparse
import socket
import threading
from flask import Flask, request, jsonify, render_template
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime, timedelta
import os
import time
from werkzeug.utils import secure_filename


# Flask web server setup
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bypassit.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
UPLOAD_FOLDER = 'uploads'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

class Agent(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    agent_id = db.Column(db.String(80), unique=True, nullable=False)
    computer_name = db.Column(db.String(80), nullable=False)
    status = db.Column(db.String(80), nullable=False, default='online')
    last_checkin = db.Column(db.DateTime, default=datetime.utcnow)
    pending_command = db.Column(db.String(200), nullable=True)

    def __repr__(self):
        return f'<Agent {self.agent_id}>'

def init_db():
    with app.app_context():
        db.create_all()

@app.route('/')
def list_agents():
    agents = Agent.query.all()
    return render_template('agents.html', agents=agents)

@app.route('/command', methods=['POST'])
def send_command():
    data = request.json
    agent_id = data.get('agent_id')
    command = data.get('command')

    if not agent_id or not command:
        return jsonify({'error': 'Agent ID and Command are required'}), 400

    with app.app_context():
        agent = Agent.query.filter_by(agent_id=agent_id).first()
        if not agent:
            return jsonify({'error': 'Agent not found'}), 404
        
        agent.pending_command = command
        db.session.commit()
        log_message(f"Command '{command}' scheduled for agent {agent_id}")

    return jsonify({'message': f"Command '{command}' scheduled for agent {agent_id}"}), 200

@app.route('/register', methods=['POST'])
def register_agent():
    data = request.json
    agent_id = data.get('agent_id')
    computer_name = data.get('computer_name')

    if not agent_id or not computer_name:
        return jsonify({'error': 'Agent ID and Computer Name are required'}), 400
    
    with app.app_context():
        agent = Agent.query.filter_by(agent_id=agent_id).first()
        if agent:
            agent.computer_name = computer_name
            agent.status = 'online'
            agent.last_checkin = datetime.utcnow()
        else:
            agent = Agent(agent_id=agent_id, computer_name=computer_name, status='online', last_checkin=datetime.utcnow())
            db.session.add(agent)
        db.session.commit()

    return jsonify({'message': f'Agent {agent_id} registered successfully'}), 201

@app.route('/agents_data')
def agents_data():
    agents = Agent.query.all()
    agents_list = [{
        'agent_id': agent.agent_id,
        'computer_name': agent.computer_name,
        'status': agent.status,
        'last_checkin': agent.last_checkin.strftime("%Y-%m-%d %H:%M:%S")  # Format datetime for display
    } for agent in agents]
    return jsonify(agents_list)

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400
    if file:
        filename = secure_filename(file.filename)
        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
        return jsonify({'message': f'File {filename} uploaded successfully'}), 200

@app.route('/download/<filename>', methods=['GET'])
def download_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename, as_attachment=True)

def update_agent_status():
    """Update the status of agents based on their last check-in time."""
    with app.app_context():
        now = datetime.utcnow()
        threshold = now - timedelta(minutes=5)  # Set threshold for offline status

        agents = Agent.query.all()
        for agent in agents:
            if agent.last_checkin < threshold:
                agent.status = 'offline'
            else:
                agent.status = 'online'
        db.session.commit()

def log_message(message):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {message}")

def start_status_check():
    while True:
        update_agent_status()
        time.sleep(60)

def handle_client(conn, addr):
    log_message(f"New connection from {addr}")
    try:
        while True:
            data = conn.recv(4096).decode('utf-8').strip()
            if not data:
                break
            log_message(f"Received data from agent: {data}")

            response = "Invalid command"  # Default response

            if data.startswith("register|"):
                parts = data.split("|")
                if len(parts) == 3:
                    agent_id = parts[1]
                    computer_name = parts[2]
                    log_message(f"Received agent registration: ID={agent_id}, ComputerName={computer_name}")
                    
                    with app.app_context():
                        agent = Agent.query.filter_by(agent_id=agent_id).first()
                        if not agent:
                            agent = Agent(agent_id=agent_id, computer_name=computer_name, status='online', last_checkin=datetime.utcnow())
                            db.session.add(agent)
                        else:
                            agent.computer_name = computer_name
                            agent.status = 'online'
                            agent.last_checkin = datetime.utcnow()
                        db.session.commit()
                        log_message(f"Agent {agent_id} registered or updated")
                    response = "Registration successful"  # Response for registration

            elif data.startswith("request_action|"):
                agent_id = data.split("|")[1]
                log_message(f"Action request from agent {agent_id}")
                with app.app_context():
                    agent = Agent.query.filter_by(agent_id=agent_id).first()
                    if agent and agent.pending_command:
                        log_message(f"Pending command for agent {agent_id}: {agent.pending_command}")
                        if agent.pending_command.startswith("download_file "):
                            # Handle file download command
                            filename = agent.pending_command.split(" ", 1)[1]
                            response = f"download_file|{filename}"
                        elif agent.pending_command.startswith("upload_file "):
                            # Handle file upload command
                            filepath = agent.pending_command.split(" ", 1)[1]
                            response = f"upload_file|{filepath}"
                        else:
                            # Regular command execution
                            response = f"execute_command|{agent.pending_command}"
                        agent.pending_command = None  # Clear command after sending
                        db.session.commit()
                    else:
                        response = "no_pending_commands"
                log_message(f"Responding to request_action for agent {agent_id}: {response}")

            log_message(f"Sending response to agent: {response}")
            conn.sendall((response + "\n").encode('utf-8'))

    except Exception as e:
        log_message(f"Error handling client {addr}: {e}")
    finally:
        conn.close()
        log_message(f"Connection closed for {addr}")

def handle_file_transfer(conn, addr):
    log_message(f"File transfer initiated from {addr}")
    try:
        # Send immediate acknowledgment
        conn.send(b'READY')
        log_message(f"Sent READY signal to {addr}")

        data = conn.recv(1024).decode('utf-8').strip()
        log_message(f"Received data from agent: {data}")
        
        if not data:
            log_message("Received empty data from agent")
            return

        parts = data.split('|')
        if len(parts) != 2:
            log_message(f"Invalid data format received: {data}")
            return

        direction, filename = parts
        
        if direction == 'from_agent':
            # Receive file from agent
            log_message(f"Preparing to receive file: {filename}")
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))
            with open(filepath, 'wb') as f:
                while True:
                    data = conn.recv(4096)
                    if data.endswith(b'\r\n{EOF}'):
                        f.write(data[:-7])
                        break
                    f.write(data)
            log_message(f"File {filename} received from agent {addr}")
        
        elif direction == 'to_agent':
            # Send file to agent
            log_message(f"Preparing to send file: {filename}")
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))
            if os.path.exists(filepath):
                file_size = os.path.getsize(filepath)
                log_message(f"File found, sending file info")
                conn.send(f"{filename}|{file_size}".encode('utf-8'))
                
                # Wait for START signal from agent
                start_signal = conn.recv(1024).decode('utf-8').strip()
                if start_signal != "START":
                    log_message(f"Invalid start signal received: {start_signal}")
                    return

                with open(filepath, 'rb') as f:
                    while True:
                        data = f.read(4096)
                        if not data:
                            break
                        conn.send(data)
                log_message(f"File {filename} sent to agent {addr}")
            else:
                log_message(f"File not found: {filepath}")
                conn.send(b'FILE_NOT_FOUND')
        else:
            log_message(f"Invalid direction received: {direction}")
    
    except Exception as e:
        log_message(f"Error in file transfer: {str(e)}")
    finally:
        conn.close()
        log_message(f"File transfer connection closed for {addr}")

def start_file_transfer_server():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('0.0.0.0', 5075))
    server.listen(5)
    log_message("File transfer server listening on port 5075")
    while True:
        conn, addr = server.accept()
        file_thread = threading.Thread(target=handle_file_transfer, args=(conn, addr))
        file_thread.start()

def start_cli_server():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('0.0.0.0', 5074))
    server.listen(5)
    log_message("CLI server listening on port 5074")
    while True:
        conn, addr = server.accept()
        client_thread = threading.Thread(target=handle_client, args=(conn, addr))
        client_thread.start()

def main():
    parser = argparse.ArgumentParser(description='BypassIT Management Server')
    parser.add_argument('--cli', action='store_true', help='Start the CLI server')
    parser.add_argument('--web', action='store_true', help='Start the web server')
    args = parser.parse_args()

    # Print the database file location
    database_uri = app.config['SQLALCHEMY_DATABASE_URI']
    if database_uri.startswith('sqlite:///'):
        db_path = database_uri.split('sqlite:///')[1]
        abs_db_path = os.path.abspath(db_path)
        print(f"Database location: {abs_db_path}")

    if args.cli:
        threading.Thread(target=start_cli_server).start()
        threading.Thread(target=start_file_transfer_server).start()

    if args.web:
        init_db()
        threading.Thread(target=start_web_server).start()

        status_thread = threading.Thread(target=start_status_check)
        status_thread.daemon = True
        status_thread.start()

def start_web_server():
    app.run(host='0.0.0.0', port=8080)

if __name__ == '__main__':
    main()
